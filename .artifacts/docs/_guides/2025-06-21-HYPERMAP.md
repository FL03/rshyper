---
description: A map-based implementation of a hypergraph
title: HyperMap
permalink: /guides/hypermap/
---

{: .no_toc }

## Table of Contents

{: .no_toc .text-delta }

1. TOC
{:toc}

## Overview

This implementation focuses on providing a flexible and efficient representation of a hypergraph. The [`HyperMap`](https://docs.rs/rshyper/latest/rshyper/struct.HyperMap.html) is parameterized by the following types:

- `N`: the type of weight associated with a hypernode
- `E`: the type of weight associated with a hyperedge
- `A`: the attributes of the graph are implementors of the [`GraphProps`](https://docs.rs/rshyper/latest/rshyper/trait.GraphProps.html) trait
  - `A::Kind`: the _kind_ of hypergraph, either [`Directed`](https://docs.rs/rshyper/latest/rshyper/struct.Directed.html) or [`Undirected`](https://docs.rs/rshyper/latest/rshyper/struct.Undirected.html)
  - `A::Ix`: the type of indices used by the instance; bounded by the [`RawIndex` trait
- `S`: the type of [`BuildHasher`] used for the underling stores

This is done to maximize compatibility and flexibility, allowing users to define their own hypergraphs with custom node and edge types, as well as different index types and hashers.

### Backend

The underlying storage mechanics are based on the [`hashbrown`](https://docs.rs/hashbrown) crate, which is a Rust implementation of [Google's SwissTable](https://abseil.io/blog/20180927-swisstables) algorithm. This is largely done to benfit from the additional feature set natively available within the crate versus the standard `HashMap`](std::collections::HashMap) implementation. That being said, it is important to note that for any applications where security it a concerin it is highly recommended to use the [`RandomState`](std::hash::RandomState) as the default hasher in lieu of the [`DefaultHashBuilder`] from [`foldhash`](https://docs.rs/foldhash) as it fails to prevent against attacks such as `Hash-DoS`. See the [`hashbrown`](https://docs.rs/hashbrown) for more information on the security implications of using a custom hasher.

## Features

The [`HyperMap`] supports various features to enhance its functionality:

- `algo`: enables the algorithmic operators from the [`rshyper_algo`](https://docs.rs/rshyper_algo) crate
- `rayon`: enables parallel processing capabilities using the [`rayon`](https://docs.rs/rayon) crate
- `serde`: enables serialization and deserialization of hypergraphs using the `serde` crate

## Examples

For more detailed examples, please refer to the [examples directory](https://github.com/FL03/rshyper/blob/main/rshyper/examples).

### _Example #1: Basic Usage_

```rust
use rshyper::{HyperMap, Weight};
// initialize a ne, undirected hypergraph
let mut graph = HyperMap::<i32, i32>::undirected();
// insert some nodes with and without weights
let v0 = graph.add_vertex().expect("failed to add vertex");
let v1 = graph.add_node(Weight(42)).expect("failed to add the node");
let v2 = graph.add_node(Weight(100)).expect("failed to add the node");
// insert an edge between the two nodes
let e0 = graph.add_edge([v0, v1, v2], Weight(100)).expect("failed to add edge");
// verify the size of the graph; (number of edges)
assert_eq!(graph.size(), 1);
// verify the order of the graph; (number of nodes)
assert_eq!(graph.order(), 3);
```
